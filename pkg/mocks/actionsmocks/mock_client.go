// Code generated by mockery v2.36.0. DO NOT EDIT.

package actionsmocks

import (
	context "context"

	actions "github.com/hostfactor/api/go/blueprint/actions"

	mock "github.com/stretchr/testify/mock"

	pkgactions "github.com/hostfactor/diazo/pkg/actions"
)

// Client is an autogenerated mock type for the Client type
type Client struct {
	mock.Mock
}

type Client_Expecter struct {
	mock *mock.Mock
}

func (_m *Client) EXPECT() *Client_Expecter {
	return &Client_Expecter{mock: &_m.Mock}
}

// Download provides a mock function with given fields: root, dl, opts
func (_m *Client) Download(root string, dl *actions.DownloadFile, opts pkgactions.DownloadOpts) error {
	ret := _m.Called(root, dl, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *actions.DownloadFile, pkgactions.DownloadOpts) error); ok {
		r0 = rf(root, dl, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_Download_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Download'
type Client_Download_Call struct {
	*mock.Call
}

// Download is a helper method to define mock.On call
//   - root string
//   - dl *actions.DownloadFile
//   - opts pkgactions.DownloadOpts
func (_e *Client_Expecter) Download(root interface{}, dl interface{}, opts interface{}) *Client_Download_Call {
	return &Client_Download_Call{Call: _e.mock.On("Download", root, dl, opts)}
}

func (_c *Client_Download_Call) Run(run func(root string, dl *actions.DownloadFile, opts pkgactions.DownloadOpts)) *Client_Download_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*actions.DownloadFile), args[2].(pkgactions.DownloadOpts))
	})
	return _c
}

func (_c *Client_Download_Call) Return(_a0 error) *Client_Download_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Download_Call) RunAndReturn(run func(string, *actions.DownloadFile, pkgactions.DownloadOpts) error) *Client_Download_Call {
	_c.Call.Return(run)
	return _c
}

// Extract provides a mock function with given fields: file
func (_m *Client) Extract(file *actions.ExtractFiles) error {
	ret := _m.Called(file)

	var r0 error
	if rf, ok := ret.Get(0).(func(*actions.ExtractFiles) error); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_Extract_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Extract'
type Client_Extract_Call struct {
	*mock.Call
}

// Extract is a helper method to define mock.On call
//   - file *actions.ExtractFiles
func (_e *Client_Expecter) Extract(file interface{}) *Client_Extract_Call {
	return &Client_Extract_Call{Call: _e.mock.On("Extract", file)}
}

func (_c *Client_Extract_Call) Run(run func(file *actions.ExtractFiles)) *Client_Extract_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*actions.ExtractFiles))
	})
	return _c
}

func (_c *Client_Extract_Call) Return(_a0 error) *Client_Extract_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Extract_Call) RunAndReturn(run func(*actions.ExtractFiles) error) *Client_Extract_Call {
	_c.Call.Return(run)
	return _c
}

// MoveFile provides a mock function with given fields: a
func (_m *Client) MoveFile(a *actions.MoveFile) error {
	ret := _m.Called(a)

	var r0 error
	if rf, ok := ret.Get(0).(func(*actions.MoveFile) error); ok {
		r0 = rf(a)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_MoveFile_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'MoveFile'
type Client_MoveFile_Call struct {
	*mock.Call
}

// MoveFile is a helper method to define mock.On call
//   - a *actions.MoveFile
func (_e *Client_Expecter) MoveFile(a interface{}) *Client_MoveFile_Call {
	return &Client_MoveFile_Call{Call: _e.mock.On("MoveFile", a)}
}

func (_c *Client_MoveFile_Call) Run(run func(a *actions.MoveFile)) *Client_MoveFile_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*actions.MoveFile))
	})
	return _c
}

func (_c *Client_MoveFile_Call) Return(_a0 error) *Client_MoveFile_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_MoveFile_Call) RunAndReturn(run func(*actions.MoveFile) error) *Client_MoveFile_Call {
	_c.Call.Return(run)
	return _c
}

// Rename provides a mock function with given fields: r
func (_m *Client) Rename(r *actions.RenameFiles) error {
	ret := _m.Called(r)

	var r0 error
	if rf, ok := ret.Get(0).(func(*actions.RenameFiles) error); ok {
		r0 = rf(r)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_Rename_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Rename'
type Client_Rename_Call struct {
	*mock.Call
}

// Rename is a helper method to define mock.On call
//   - r *actions.RenameFiles
func (_e *Client_Expecter) Rename(r interface{}) *Client_Rename_Call {
	return &Client_Rename_Call{Call: _e.mock.On("Rename", r)}
}

func (_c *Client_Rename_Call) Run(run func(r *actions.RenameFiles)) *Client_Rename_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*actions.RenameFiles))
	})
	return _c
}

func (_c *Client_Rename_Call) Return(_a0 error) *Client_Rename_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Rename_Call) RunAndReturn(run func(*actions.RenameFiles) error) *Client_Rename_Call {
	_c.Call.Return(run)
	return _c
}

// Shell provides a mock function with given fields: ctx, a
func (_m *Client) Shell(ctx context.Context, a *actions.Shell) ([]byte, error) {
	ret := _m.Called(ctx, a)

	var r0 []byte
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *actions.Shell) ([]byte, error)); ok {
		return rf(ctx, a)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *actions.Shell) []byte); ok {
		r0 = rf(ctx, a)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *actions.Shell) error); ok {
		r1 = rf(ctx, a)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Client_Shell_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Shell'
type Client_Shell_Call struct {
	*mock.Call
}

// Shell is a helper method to define mock.On call
//   - ctx context.Context
//   - a *actions.Shell
func (_e *Client_Expecter) Shell(ctx interface{}, a interface{}) *Client_Shell_Call {
	return &Client_Shell_Call{Call: _e.mock.On("Shell", ctx, a)}
}

func (_c *Client_Shell_Call) Run(run func(ctx context.Context, a *actions.Shell)) *Client_Shell_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(context.Context), args[1].(*actions.Shell))
	})
	return _c
}

func (_c *Client_Shell_Call) Return(_a0 []byte, _a1 error) *Client_Shell_Call {
	_c.Call.Return(_a0, _a1)
	return _c
}

func (_c *Client_Shell_Call) RunAndReturn(run func(context.Context, *actions.Shell) ([]byte, error)) *Client_Shell_Call {
	_c.Call.Return(run)
	return _c
}

// Unzip provides a mock function with given fields: file
func (_m *Client) Unzip(file *actions.UnzipFile) error {
	ret := _m.Called(file)

	var r0 error
	if rf, ok := ret.Get(0).(func(*actions.UnzipFile) error); ok {
		r0 = rf(file)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_Unzip_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Unzip'
type Client_Unzip_Call struct {
	*mock.Call
}

// Unzip is a helper method to define mock.On call
//   - file *actions.UnzipFile
func (_e *Client_Expecter) Unzip(file interface{}) *Client_Unzip_Call {
	return &Client_Unzip_Call{Call: _e.mock.On("Unzip", file)}
}

func (_c *Client_Unzip_Call) Run(run func(file *actions.UnzipFile)) *Client_Unzip_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*actions.UnzipFile))
	})
	return _c
}

func (_c *Client_Unzip_Call) Return(_a0 error) *Client_Unzip_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Unzip_Call) RunAndReturn(run func(*actions.UnzipFile) error) *Client_Unzip_Call {
	_c.Call.Return(run)
	return _c
}

// Upload provides a mock function with given fields: root, u, opts
func (_m *Client) Upload(root string, u *actions.UploadFile, opts pkgactions.UploadOpts) error {
	ret := _m.Called(root, u, opts)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, *actions.UploadFile, pkgactions.UploadOpts) error); ok {
		r0 = rf(root, u, opts)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_Upload_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Upload'
type Client_Upload_Call struct {
	*mock.Call
}

// Upload is a helper method to define mock.On call
//   - root string
//   - u *actions.UploadFile
//   - opts pkgactions.UploadOpts
func (_e *Client_Expecter) Upload(root interface{}, u interface{}, opts interface{}) *Client_Upload_Call {
	return &Client_Upload_Call{Call: _e.mock.On("Upload", root, u, opts)}
}

func (_c *Client_Upload_Call) Run(run func(root string, u *actions.UploadFile, opts pkgactions.UploadOpts)) *Client_Upload_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(string), args[1].(*actions.UploadFile), args[2].(pkgactions.UploadOpts))
	})
	return _c
}

func (_c *Client_Upload_Call) Return(_a0 error) *Client_Upload_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Upload_Call) RunAndReturn(run func(string, *actions.UploadFile, pkgactions.UploadOpts) error) *Client_Upload_Call {
	_c.Call.Return(run)
	return _c
}

// Zip provides a mock function with given fields: z
func (_m *Client) Zip(z *actions.ZipFile) error {
	ret := _m.Called(z)

	var r0 error
	if rf, ok := ret.Get(0).(func(*actions.ZipFile) error); ok {
		r0 = rf(z)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// Client_Zip_Call is a *mock.Call that shadows Run/Return methods with type explicit version for method 'Zip'
type Client_Zip_Call struct {
	*mock.Call
}

// Zip is a helper method to define mock.On call
//   - z *actions.ZipFile
func (_e *Client_Expecter) Zip(z interface{}) *Client_Zip_Call {
	return &Client_Zip_Call{Call: _e.mock.On("Zip", z)}
}

func (_c *Client_Zip_Call) Run(run func(z *actions.ZipFile)) *Client_Zip_Call {
	_c.Call.Run(func(args mock.Arguments) {
		run(args[0].(*actions.ZipFile))
	})
	return _c
}

func (_c *Client_Zip_Call) Return(_a0 error) *Client_Zip_Call {
	_c.Call.Return(_a0)
	return _c
}

func (_c *Client_Zip_Call) RunAndReturn(run func(*actions.ZipFile) error) *Client_Zip_Call {
	_c.Call.Return(run)
	return _c
}

// NewClient creates a new instance of Client. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewClient(t interface {
	mock.TestingT
	Cleanup(func())
}) *Client {
	mock := &Client{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
