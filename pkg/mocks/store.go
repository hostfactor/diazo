// Code generated by mockery v2.14.0. DO NOT EDIT.

package mocks

import (
	blueprint "github.com/hostfactor/api/go/blueprint"
	mock "github.com/stretchr/testify/mock"

	reaction "github.com/hostfactor/api/go/blueprint/reaction"

	variable "github.com/hostfactor/diazo/pkg/variable"
)

// Store is an autogenerated mock type for the Store type
type Store struct {
	mock.Mock
}

// AddEntries provides a mock function with given fields: entries
func (_m *Store) AddEntries(entries ...*variable.Entry) {
	_va := make([]interface{}, len(entries))
	for _i := range entries {
		_va[_i] = entries[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// AddFileTemplateData provides a mock function with given fields: d
func (_m *Store) AddFileTemplateData(d ...*reaction.FileReactionTemplateData) {
	_va := make([]interface{}, len(d))
	for _i := range d {
		_va[_i] = d[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// AddLogTemplateData provides a mock function with given fields: d
func (_m *Store) AddLogTemplateData(d ...*reaction.LogReactionTemplateData) {
	_va := make([]interface{}, len(d))
	for _i := range d {
		_va[_i] = d[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// AddVariable provides a mock function with given fields: vars
func (_m *Store) AddVariable(vars ...*blueprint.Variable) {
	_va := make([]interface{}, len(vars))
	for _i := range vars {
		_va[_i] = vars[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// Get provides a mock function with given fields: key
func (_m *Store) Get(key string) *blueprint.Variable {
	ret := _m.Called(key)

	var r0 *blueprint.Variable
	if rf, ok := ret.Get(0).(func(string) *blueprint.Variable); ok {
		r0 = rf(key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*blueprint.Variable)
		}
	}

	return r0
}

// GetStringValue provides a mock function with given fields: key
func (_m *Store) GetStringValue(key string) string {
	ret := _m.Called(key)

	var r0 string
	if rf, ok := ret.Get(0).(func(string) string); ok {
		r0 = rf(key)
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

// Len provides a mock function with given fields:
func (_m *Store) Len() int {
	ret := _m.Called()

	var r0 int
	if rf, ok := ret.Get(0).(func() int); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(int)
	}

	return r0
}

// Range provides a mock function with given fields: f
func (_m *Store) Range(f func(string, *blueprint.Variable) bool) {
	_m.Called(f)
}

// RemoveVariable provides a mock function with given fields: vars
func (_m *Store) RemoveVariable(vars ...*blueprint.Variable) {
	_va := make([]interface{}, len(vars))
	for _i := range vars {
		_va[_i] = vars[_i]
	}
	var _ca []interface{}
	_ca = append(_ca, _va...)
	_m.Called(_ca...)
}

// String provides a mock function with given fields:
func (_m *Store) String() string {
	ret := _m.Called()

	var r0 string
	if rf, ok := ret.Get(0).(func() string); ok {
		r0 = rf()
	} else {
		r0 = ret.Get(0).(string)
	}

	return r0
}

type mockConstructorTestingTNewStore interface {
	mock.TestingT
	Cleanup(func())
}

// NewStore creates a new instance of Store. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
func NewStore(t mockConstructorTestingTNewStore) *Store {
	mock := &Store{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
